<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>CMS</title>
    <!-- HEAD 안 -->
<style id="decap-cms-scroll-fix">
/* --- Force Decap CMS to occupy the viewport and scroll correctly --- */
html, body {
  margin: 0 !important;
  padding: 0 !important;
  width: 100% !important;
  height: auto !important;
  min-height: 100vh !important;
  overflow: auto !important;
  position: static !important;
  scroll-behavior: auto !important;
  overscroll-behavior: none !important;
}

/* Prevent any accidental page-level scaling/centering */
html, body, #nc-root, .CMS_App_root, main {
  transform: none !important;
  zoom: 1 !important;
  max-width: none !important;
  width: 100% !important;
  margin: 0 !important;
  padding: 0 !important;
}

#nc-root, #nc-root > div, main {
  height: auto !important;
  min-height: 100vh !important;
  overflow: auto !important;
  position: static !important;
}

/* Make every internal pane a normal auto-height scroll container */
.Pane_root, .Pane_content, .Pane_scrollContainer,
.CollectionContainer_container,
.DefaultCollectionPage_container,
.DefaultControlPane_container,
.EditorContainer_root,
.ReactVirtualized__Grid, .ReactVirtualized__List,
.ReactVirtualized__Grid__innerScrollContainer {
  max-height: none !important;
  height: auto !important;
  min-height: 100% !important;
  overflow: auto !important;
  position: static !important;
  transform: none !important;
  margin: 0 !important;
  padding: 0 !important;
}

/* Kill inline overflow hidden that blocks scrolling */
*[style*="overflow: hidden"], *[style*="overflow:hidden"] {
  overflow: auto !important;
}

/* Ensure the list page starts at the very top-left */
.CMS_App_root, .DefaultCollectionPage_container {
  align-items: flex-start !important;
  justify-content: flex-start !important;
}

/* Box sizing consistency to avoid weird centering/gaps */
*, *::before, *::after { box-sizing: border-box; }

/* --- Remove any phantom top gap (margin/padding/pseudo banners) --- */
html, body, #nc-root, #nc-root > div, .CMS_App_root, main,
.Pane_root, .DefaultCollectionPage_container, .EditorContainer_root {
  margin-top: 0 !important;
  padding-top: 0 !important;
}
/* Some themes inject a top :before strip – disable it */
body::before, body::after, #nc-root::before, #nc-root::after,
.CMS_App_root::before, .CMS_App_root::after {
  content: none !important;
  display: none !important;
}
/* Ensure the page is not vertically centered leaving a big gap */
body, #nc-root, .CMS_App_root {
  display: block !important;
  align-items: flex-start !important;
  justify-content: flex-start !important;
}
</style>
  </head>
  <body>
    <!-- ✅ Decap가 여기에 렌더링한다 -->
    <div id="nc-root"></div>

    <!-- (선택) Netlify Identity 위젯 -->
    <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>

    <!-- ✅ Decap CMS v3 core -->
    <script src="https://unpkg.com/decap-cms@^3.0.0/dist/decap-cms.js"></script>

    <!-- ✅ Netlify(= git-gateway) 백엔드 플러그인 -->
    <script src="https://unpkg.com/decap-cms-backend-netlify@^3.0.0/dist/standalone.js"></script>

    <!-- 자동 초기화가 기본값이라 따로 CMS.init()는 보통 필요 없음 -->
     <!-- BODY 끝 직전 -->
<script id="decap-cms-scroll-fix-runtime">
(function () {
  function fix() {
    try {
      ['html','body'].forEach(function(s){
        var el = document.querySelector(s);
        if (!el) return;
        el.style.setProperty('overflow','auto','important');
        el.style.setProperty('height','auto','important');
        el.style.setProperty('min-height','100vh','important');
        el.style.setProperty('position','static','important');
      });
      var sels = [
        '#nc-root','main','.Pane_root','.Pane_content','.Pane_scrollContainer',
        '.CollectionContainer_container','.DefaultCollectionPage_container',
        '.DefaultControlPane_container','.EditorContainer_root',
        '.ReactVirtualized__Grid','.ReactVirtualized__List',
        '.ReactVirtualized__Grid__innerScrollContainer'
      ];
      sels.forEach(function (sel) {
        document.querySelectorAll(sel).forEach(function (el) {
          el.style.setProperty('max-height','none','important');
          el.style.setProperty('height','auto','important');
          el.style.setProperty('min-height','100%','important');
          el.style.setProperty('overflow','auto','important');
        });
      });
      var root = document.getElementById('nc-root');
      if (root) {
        root.style.removeProperty('transform');
        root.style.removeProperty('max-width');
        root.style.setProperty('width','100%','important');
      }
      document.querySelectorAll('[style*="overflow: hidden"]').forEach(function (el) {
        el.style.setProperty('overflow','auto','important');
      });
    } catch(e) {}

    // Remove any top margin/padding that could push the UI down
    var tops = ['html','body','#nc-root','#nc-root > div','.CMS_App_root','main',
                '.Pane_root','.DefaultCollectionPage_container','.EditorContainer_root'];
    tops.forEach(function(sel){
      document.querySelectorAll(sel).forEach(function(el){
        try{
          el.style.setProperty('margin-top','0','important');
          el.style.setProperty('padding-top','0','important');
        }catch(e){}
      });
    });
  }
  function burst(){
    var i=0, t=setInterval(function(){ fix(); if(++i>40) clearInterval(t); },500);
  }
  function goTop(){
    try { history.scrollRestoration = 'manual'; } catch(e){}
    try { document.documentElement.style.scrollPaddingTop = '0px'; } catch(e){}
    var targets = [
      document.scrollingElement || document.documentElement,
      document.body,
      document.getElementById('nc-root')
    ];
    var sels = [
      '.Pane_root','.Pane_content','.Pane_scrollContainer',
      '.CollectionContainer_container','.DefaultCollectionPage_container',
      '.DefaultControlPane_container','.EditorContainer_root',
      '.ReactVirtualized__Grid','.ReactVirtualized__List',
      '.ReactVirtualized__Grid__innerScrollContainer'
    ];
    try {
      sels.forEach(function(sel){
        document.querySelectorAll(sel).forEach(function(el){ targets.push(el); });
      });
    } catch(e){}
    try { window.scrollTo(0,0); } catch(e) {}
    setTimeout(function(){ window.scrollTo(0,0); }, 50);
    targets.forEach(function(el){ try { el.scrollTop = 0; } catch(e){} });
    // 두 번 보정: 렌더 직후 & 다음 프레임
    try {
      requestAnimationFrame(function(){
        try { window.scrollTo(0,0); } catch(e) {}
        targets.forEach(function(el){ try { el.scrollTop = 0; } catch(e){} });
      });
      setTimeout(function(){
        try { window.scrollTo(0,0); } catch(e) {}
        targets.forEach(function(el){ try { el.scrollTop = 0; } catch(e){} });
      }, 150);
    } catch(e){}
  }
  document.addEventListener('DOMContentLoaded', function(){ burst(); setTimeout(goTop, 0); });
  window.addEventListener('load', function(){ burst(); setTimeout(goTop, 0); });
  window.addEventListener('resize', fix);
  var _p=history.pushState; history.pushState=function(){ _p.apply(this,arguments); setTimeout(function(){ burst(); goTop(); },100); };
  var _r=history.replaceState; history.replaceState=function(){ _r.apply(this,arguments); setTimeout(function(){ burst(); goTop(); },100); };
})();
</script>
  </body>
</html>